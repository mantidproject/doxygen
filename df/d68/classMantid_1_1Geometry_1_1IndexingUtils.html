<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mantid: Mantid::Geometry::IndexingUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-59110517-2', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mantid
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d8/d8e/namespaceMantid.html">Mantid</a></li><li class="navelem"><a class="el" href="../../dc/d67/namespaceMantid_1_1Geometry.html">Geometry</a></li><li class="navelem"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html">IndexingUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="../../db/d91/classMantid_1_1Geometry_1_1IndexingUtils-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Mantid::Geometry::IndexingUtils Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class contains static utility methods for indexing peaks and finding the UB matrix.  
 <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/de5/IndexingUtils_8h_source.html">IndexingUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aea5372b634886144fd40b4d1dcbc3372"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aea5372b634886144fd40b4d1dcbc3372">CalculateMillerIndices</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;inverseUB, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;q_vector)</td></tr>
<tr class="memdesc:aea5372b634886144fd40b4d1dcbc3372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a UB, calculate the miller indices for given q vector.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aea5372b634886144fd40b4d1dcbc3372">More...</a><br /></td></tr>
<tr class="separator:aea5372b634886144fd40b4d1dcbc3372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3ee81a1b10f0679fb5de679f581722"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ace3ee81a1b10f0679fb5de679f581722">CalculateMillerIndices</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;inverseUB, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;q_vector, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>, <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;miller_indices)</td></tr>
<tr class="memdesc:ace3ee81a1b10f0679fb5de679f581722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a UB, calculate the miller indices for given q vector.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ace3ee81a1b10f0679fb5de679f581722">More...</a><br /></td></tr>
<tr class="separator:ace3ee81a1b10f0679fb5de679f581722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff851f0a060ce19e3e703abe3e941634"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aff851f0a060ce19e3e703abe3e941634">CalculateMillerIndices</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;miller_indices, double &amp;ave_error)</td></tr>
<tr class="memdesc:aff851f0a060ce19e3e703abe3e941634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a UB, get list of Miller indices for specifed Qs and tolerance.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aff851f0a060ce19e3e703abe3e941634">More...</a><br /></td></tr>
<tr class="separator:aff851f0a060ce19e3e703abe3e941634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c022eae677abc18940c7bfcbc88a5f7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a8c022eae677abc18940c7bfcbc88a5f7">CheckUB</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB)</td></tr>
<tr class="memdesc:a8c022eae677abc18940c7bfcbc88a5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the specified UB is reasonable for an orientation matrix.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a8c022eae677abc18940c7bfcbc88a5f7">More...</a><br /></td></tr>
<tr class="separator:a8c022eae677abc18940c7bfcbc88a5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4400ab417ec6dc3477f8c43e4eef78"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a2d4400ab417ec6dc3477f8c43e4eef78">DiscardDuplicates</a> (std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;new_list, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;directions, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double required_tolerance, double len_tol, double ang_tol)</td></tr>
<tr class="memdesc:a2d4400ab417ec6dc3477f8c43e4eef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sublist of the specified list of a,b,c directions, by removing all directions that seem to be duplicates.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a2d4400ab417ec6dc3477f8c43e4eef78">More...</a><br /></td></tr>
<tr class="separator:a2d4400ab417ec6dc3477f8c43e4eef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8">FFTScanFor_Directions</a> (std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;directions, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double min_d, double max_d, double required_tolerance, double degrees_per_step)</td></tr>
<tr class="memdesc:a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use FFT to get list of possible directions and lengths for real space unit cell.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8">More...</a><br /></td></tr>
<tr class="separator:a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6be7480a624d2226ee3147b9c962be"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a3a6be7480a624d2226ee3147b9c962be">Find_UB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double min_d, double max_d, double required_tolerance, double degrees_per_step, int iterations=4)</td></tr>
<tr class="memdesc:a3a6be7480a624d2226ee3147b9c962be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the UB matrix that most nearly indexes the specified qxyz values using FFTs, given the range of possible real space unit cell edge lengths.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a3a6be7480a624d2226ee3147b9c962be">More...</a><br /></td></tr>
<tr class="separator:a3a6be7480a624d2226ee3147b9c962be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d478cd51f5db419ca954b57584f692"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aa0d478cd51f5db419ca954b57584f692">Find_UB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double min_d, double max_d, double required_tolerance, int base_index, size_t num_initial, double degrees_per_step)</td></tr>
<tr class="memdesc:aa0d478cd51f5db419ca954b57584f692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the UB matrix that most nearly indexes the specified qxyz values given the range of possible real space unit cell edge lengths.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aa0d478cd51f5db419ca954b57584f692">More...</a><br /></td></tr>
<tr class="separator:aa0d478cd51f5db419ca954b57584f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c90b22c0ead5a4c3f2b7d9f51ad19"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a5f2c90b22c0ead5a4c3f2b7d9f51ad19">Find_UB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, <a class="el" href="../../de/ded/classMantid_1_1Geometry_1_1OrientedLattice.html">OrientedLattice</a> &amp;lattice, double required_tolerance, int base_index, size_t num_initial, double degrees_per_step, bool fixAll=false, int iterations=1)</td></tr>
<tr class="memdesc:a5f2c90b22c0ead5a4c3f2b7d9f51ad19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the UB matrix that most nearly indexes the specified qxyz values given the lattice parameters.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a5f2c90b22c0ead5a4c3f2b7d9f51ad19">More...</a><br /></td></tr>
<tr class="separator:a5f2c90b22c0ead5a4c3f2b7d9f51ad19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b59187425e0b6ebcec437244b4e5b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a549b59187425e0b6ebcec437244b4e5b">FormUB_From_abc_Vectors</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;directions, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double req_tolerance, double min_vol)</td></tr>
<tr class="memdesc:a549b59187425e0b6ebcec437244b4e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form a UB matrix by choosing three vectors from list of possible a,b,c to maximize the number of peaks indexed and minimize cell volume.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a549b59187425e0b6ebcec437244b4e5b">More...</a><br /></td></tr>
<tr class="separator:a549b59187425e0b6ebcec437244b4e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44e7052344de6324e5d8b7096ff927"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#adf44e7052344de6324e5d8b7096ff927">FormUB_From_abc_Vectors</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;directions, size_t a_index, double min_d, double max_d)</td></tr>
<tr class="memdesc:adf44e7052344de6324e5d8b7096ff927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to form a UB matrix from three vectors chosen from list of possible a,b,c directions, starting with the a vector at the given index.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#adf44e7052344de6324e5d8b7096ff927">More...</a><br /></td></tr>
<tr class="separator:adf44e7052344de6324e5d8b7096ff927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1d31c539bf744a2aa6b4110f6df845"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a4a1d31c539bf744a2aa6b4110f6df845">GetFirstMaxIndex</a> (const double magnitude_fft[], size_t N, double threshold)</td></tr>
<tr class="memdesc:a4a1d31c539bf744a2aa6b4110f6df845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of the first maximum (beyond the DC term) in the |FFT| that exceeds the specified threshold.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a4a1d31c539bf744a2aa6b4110f6df845">More...</a><br /></td></tr>
<tr class="separator:a4a1d31c539bf744a2aa6b4110f6df845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ab133289f37fcd1f81e7f79bfc8c0f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a07ab133289f37fcd1f81e7f79bfc8c0f">GetIndexedPeaks</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double required_tolerance, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;miller_indices, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;indexed_qs, double &amp;fit_error)</td></tr>
<tr class="memdesc:a07ab133289f37fcd1f81e7f79bfc8c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lists of indices and Qs for peaks indexed by the specified UB matrix.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a07ab133289f37fcd1f81e7f79bfc8c0f">More...</a><br /></td></tr>
<tr class="separator:a07ab133289f37fcd1f81e7f79bfc8c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2cc14be6d3d9c68c38136b423e45bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a4d2cc14be6d3d9c68c38136b423e45bb">GetIndexedPeaks_1D</a> (const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;direction, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double required_tolerance, std::vector&lt; int &gt; &amp;index_vals, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;indexed_qs, double &amp;fit_error)</td></tr>
<tr class="memdesc:a4d2cc14be6d3d9c68c38136b423e45bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lists of indices and Qs for peaks indexed in the specified direction.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a4d2cc14be6d3d9c68c38136b423e45bb">More...</a><br /></td></tr>
<tr class="separator:a4d2cc14be6d3d9c68c38136b423e45bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b311ee9931c8fd4583ebff5ae8cd6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aa01b311ee9931c8fd4583ebff5ae8cd6">GetIndexedPeaks_3D</a> (const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;direction_1, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;direction_2, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;direction_3, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double required_tolerance, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;miller_indices, std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;indexed_qs, double &amp;fit_error)</td></tr>
<tr class="memdesc:aa01b311ee9931c8fd4583ebff5ae8cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lists of indices and Qs for peaks indexed in three given directions.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aa01b311ee9931c8fd4583ebff5ae8cd6">More...</a><br /></td></tr>
<tr class="separator:aa01b311ee9931c8fd4583ebff5ae8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd121b4386108f902cae3f0a42da7d89"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#afd121b4386108f902cae3f0a42da7d89">GetLatticeParameters</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, std::vector&lt; double &gt; &amp;lattice_par)</td></tr>
<tr class="memdesc:afd121b4386108f902cae3f0a42da7d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lattice parameters for the specified orientation matrix.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#afd121b4386108f902cae3f0a42da7d89">More...</a><br /></td></tr>
<tr class="separator:afd121b4386108f902cae3f0a42da7d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3217dc6ad7f59c197478afc443654021"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a3217dc6ad7f59c197478afc443654021">GetLatticeParameterString</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB)</td></tr>
<tr class="memdesc:a3217dc6ad7f59c197478afc443654021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a formatted string listing the lattice parameters and cell volume.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a3217dc6ad7f59c197478afc443654021">More...</a><br /></td></tr>
<tr class="separator:a3217dc6ad7f59c197478afc443654021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa903e7be897186dc66b402ece32b39c2"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aa903e7be897186dc66b402ece32b39c2">GetMagFFT</a> (const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;current_dir, const size_t N, double projections[], double index_factor, double magnitude_fft[])</td></tr>
<tr class="memdesc:aa903e7be897186dc66b402ece32b39c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the magnitude of the FFT of the projections of the q_vectors on the current direction vector.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aa903e7be897186dc66b402ece32b39c2">More...</a><br /></td></tr>
<tr class="separator:aa903e7be897186dc66b402ece32b39c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc686ed5572dcece833f858acaef747"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#abbc686ed5572dcece833f858acaef747">GetModulationVector</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;ModUB, <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;ModVec, const int j)</td></tr>
<tr class="separator:abbc686ed5572dcece833f858acaef747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1825d45a3db416fd213b22fee98e1934"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a1825d45a3db416fd213b22fee98e1934">GetModulationVectors</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;ModUB, <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;ModVec1, <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;ModVec2, <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;ModVec3)</td></tr>
<tr class="separator:a1825d45a3db416fd213b22fee98e1934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1346738ddca8a39e1d9e9000f6cf0bf8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a1346738ddca8a39e1d9e9000f6cf0bf8">IndexingError</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkls, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors)</td></tr>
<tr class="memdesc:a1346738ddca8a39e1d9e9000f6cf0bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the average indexing error for UB with the specified q's and hkls.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a1346738ddca8a39e1d9e9000f6cf0bf8">More...</a><br /></td></tr>
<tr class="separator:a1346738ddca8a39e1d9e9000f6cf0bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e45be2bae7ae99fc641189f36e652d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a62e45be2bae7ae99fc641189f36e652d">makeCDir</a> (const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;a_dir, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;b_dir, const double c, const double cosAlpha, const double cosBeta, const double cosGamma, const double sinGamma)</td></tr>
<tr class="memdesc:a62e45be2bae7ae99fc641189f36e652d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector in the direction of "c" given other unit cell information.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a62e45be2bae7ae99fc641189f36e652d">More...</a><br /></td></tr>
<tr class="separator:a62e45be2bae7ae99fc641189f36e652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f70fd2c0d4eee4a4aeabbe20fea62e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a49f70fd2c0d4eee4a4aeabbe20fea62e">MakeCircleDirections</a> (int n_steps, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;axis, double angle_degrees)</td></tr>
<tr class="memdesc:a49f70fd2c0d4eee4a4aeabbe20fea62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make list of the circle of direction vectors that form a fixed angle with the specified axis.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a49f70fd2c0d4eee4a4aeabbe20fea62e">More...</a><br /></td></tr>
<tr class="separator:a49f70fd2c0d4eee4a4aeabbe20fea62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983611c692ef0e464065682b60268efe"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a983611c692ef0e464065682b60268efe">MakeHemisphereDirections</a> (int n_steps)</td></tr>
<tr class="memdesc:a983611c692ef0e464065682b60268efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make list of direction vectors uniformly distributed over a hemisphere.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a983611c692ef0e464065682b60268efe">More...</a><br /></td></tr>
<tr class="separator:a983611c692ef0e464065682b60268efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754da0909c3438eb1f533803b37af97"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a9754da0909c3438eb1f533803b37af97">NumberIndexed</a> (const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>)</td></tr>
<tr class="memdesc:a9754da0909c3438eb1f533803b37af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of Q vectors that are mapped to integer indices by UB.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a9754da0909c3438eb1f533803b37af97">More...</a><br /></td></tr>
<tr class="separator:a9754da0909c3438eb1f533803b37af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774c9ef3e1330bf6f3a637b81b741daa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a774c9ef3e1330bf6f3a637b81b741daa">NumberIndexed_1D</a> (const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;direction, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>)</td></tr>
<tr class="memdesc:a774c9ef3e1330bf6f3a637b81b741daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of Q vectors that map to an integer index in one direction.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a774c9ef3e1330bf6f3a637b81b741daa">More...</a><br /></td></tr>
<tr class="separator:a774c9ef3e1330bf6f3a637b81b741daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4430eaa5bc507c9da8d2d02f0bb1e1d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#af4430eaa5bc507c9da8d2d02f0bb1e1d">NumberIndexed_3D</a> (const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;a_dir, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;b_dir, const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;c_dir, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>)</td></tr>
<tr class="memdesc:af4430eaa5bc507c9da8d2d02f0bb1e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of Q vectors that map to integer indices simutlaneously in three directions.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#af4430eaa5bc507c9da8d2d02f0bb1e1d">More...</a><br /></td></tr>
<tr class="separator:af4430eaa5bc507c9da8d2d02f0bb1e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd6d10894c55047a3692de0683cf213"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a6dd6d10894c55047a3692de0683cf213">NumberOfValidIndexes</a> (const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkls, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>, double &amp;average_error)</td></tr>
<tr class="memdesc:a6dd6d10894c55047a3692de0683cf213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find number of valid HKLs and average error, in list of HKLs.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a6dd6d10894c55047a3692de0683cf213">More...</a><br /></td></tr>
<tr class="separator:a6dd6d10894c55047a3692de0683cf213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28ace8c20dace3d28163c7a0193021c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ac28ace8c20dace3d28163c7a0193021c">Optimize_6dUB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;ModUB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkl_vectors, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;mnp_vectors, const int &amp;ModDim, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors)</td></tr>
<tr class="memdesc:ac28ace8c20dace3d28163c7a0193021c"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATIC method Optimize_6dUB: Calculates the 6-dimensional matrix that most nearly maps the specified hkl_vectors and mnp_vectors to the specified q_vectors.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ac28ace8c20dace3d28163c7a0193021c">More...</a><br /></td></tr>
<tr class="separator:ac28ace8c20dace3d28163c7a0193021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054cc44a10aa645f77b4bc6706e51e73"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a054cc44a10aa645f77b4bc6706e51e73">Optimize_6dUB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;ModUB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkl_vectors, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;mnp_vectors, const int &amp;ModDim, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, std::vector&lt; double &gt; &amp;sigabc, std::vector&lt; double &gt; &amp;sigq)</td></tr>
<tr class="memdesc:a054cc44a10aa645f77b4bc6706e51e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATIC method Optimize_UB: Calculates the matrix that most nearly maps the specified hkl_vectors to the specified q_vectors.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a054cc44a10aa645f77b4bc6706e51e73">More...</a><br /></td></tr>
<tr class="separator:a054cc44a10aa645f77b4bc6706e51e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844e70778347bb45dddc4bc1976bd99"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a3844e70778347bb45dddc4bc1976bd99">Optimize_Direction</a> (<a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;best_vec, const std::vector&lt; int &gt; &amp;index_values, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors)</td></tr>
<tr class="memdesc:a3844e70778347bb45dddc4bc1976bd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vector that best corresponds to plane normal, given 1-D indices.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a3844e70778347bb45dddc4bc1976bd99">More...</a><br /></td></tr>
<tr class="separator:a3844e70778347bb45dddc4bc1976bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884a2b3b354e4621418a3411885f8057"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a884a2b3b354e4621418a3411885f8057">Optimize_UB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkl_vectors, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors)</td></tr>
<tr class="memdesc:a884a2b3b354e4621418a3411885f8057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the UB matrix that most nearly maps hkl to qxyz for 3 or more peaks.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a884a2b3b354e4621418a3411885f8057">More...</a><br /></td></tr>
<tr class="separator:a884a2b3b354e4621418a3411885f8057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad836b3f48459b642007618a5ebdd2f30"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ad836b3f48459b642007618a5ebdd2f30">Optimize_UB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkl_vectors, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, std::vector&lt; double &gt; &amp;sigabc)</td></tr>
<tr class="memdesc:ad836b3f48459b642007618a5ebdd2f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the UB matrix that most nearly maps hkl to qxyz for 3 or more peaks.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ad836b3f48459b642007618a5ebdd2f30">More...</a><br /></td></tr>
<tr class="separator:ad836b3f48459b642007618a5ebdd2f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e431c1770c959fa75499f961c495d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a39e431c1770c959fa75499f961c495d1">RoundHKL</a> (<a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;hkl)</td></tr>
<tr class="memdesc:a39e431c1770c959fa75499f961c495d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round all the components of a <a class="el" href="../../db/dc5/classMantid_1_1Geometry_1_1HKL.html" title="HKL : HKL MDFrame.">HKL</a> objects to the nearest integer.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a39e431c1770c959fa75499f961c495d1">More...</a><br /></td></tr>
<tr class="separator:a39e431c1770c959fa75499f961c495d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47b5d367c56d9ffaebf2874f85becd2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ab47b5d367c56d9ffaebf2874f85becd2">RoundHKLs</a> (std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;hkl_list)</td></tr>
<tr class="memdesc:ab47b5d367c56d9ffaebf2874f85becd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round all the components of a list of V3D objects, to the nearest integer.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ab47b5d367c56d9ffaebf2874f85becd2">More...</a><br /></td></tr>
<tr class="separator:ab47b5d367c56d9ffaebf2874f85becd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f88f8553a78bedb50f11568f9d99a"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ac83f88f8553a78bedb50f11568f9d99a">ScanFor_Directions</a> (std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;directions, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, double min_d, double max_d, double required_tolerance, double degrees_per_step)</td></tr>
<tr class="memdesc:ac83f88f8553a78bedb50f11568f9d99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of possible directions and lengths for real space unit cell.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ac83f88f8553a78bedb50f11568f9d99a">More...</a><br /></td></tr>
<tr class="separator:ac83f88f8553a78bedb50f11568f9d99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af434150dd99a9dd5b66c21cb6b31d5d3"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#af434150dd99a9dd5b66c21cb6b31d5d3">ScanFor_UB</a> (<a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;UB, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, const <a class="el" href="../../d4/d9c/classMantid_1_1Geometry_1_1UnitCell.html">UnitCell</a> &amp;cell, double degrees_per_step, double required_tolerance)</td></tr>
<tr class="memdesc:af434150dd99a9dd5b66c21cb6b31d5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan rotations to find UB that indexes peaks given lattice parameters.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#af434150dd99a9dd5b66c21cb6b31d5d3">More...</a><br /></td></tr>
<tr class="separator:af434150dd99a9dd5b66c21cb6b31d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644cf2e7451072170e65c5fb6f1f0f54"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a644cf2e7451072170e65c5fb6f1f0f54">SelectDirection</a> (<a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;best_direction, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;q_vectors, const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;direction_list, double plane_spacing, double required_tolerance)</td></tr>
<tr class="memdesc:a644cf2e7451072170e65c5fb6f1f0f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the direction in a list of directions, that is most nearly perpendicular to planes with the specified spacing in reciprocal space.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a644cf2e7451072170e65c5fb6f1f0f54">More...</a><br /></td></tr>
<tr class="separator:a644cf2e7451072170e65c5fb6f1f0f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0428b3c05dd21f5a5082d5a29bc57c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aed0428b3c05dd21f5a5082d5a29bc57c">ValidIndex</a> (const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;hkl, double <a class="el" href="../../d0/d66/SetUncertainties_8cpp.html#a97eab6d709b80585fe9e8a54b1e3da27">tolerance</a>)</td></tr>
<tr class="memdesc:aed0428b3c05dd21f5a5082d5a29bc57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check is hkl is within tolerance of integer (h,k,l) non-zero values.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#aed0428b3c05dd21f5a5082d5a29bc57c">More...</a><br /></td></tr>
<tr class="separator:aed0428b3c05dd21f5a5082d5a29bc57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ae602e29db9ec2a53a214fc20045305de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d2/d78/classMantid_1_1Kernel_1_1Logger.html">Mantid::Kernel::Logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ae602e29db9ec2a53a214fc20045305de">g_Log</a></td></tr>
<tr class="memdesc:ae602e29db9ec2a53a214fc20045305de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static reference to the logger class.  <a href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#ae602e29db9ec2a53a214fc20045305de">More...</a><br /></td></tr>
<tr class="separator:ae602e29db9ec2a53a214fc20045305de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This class contains static utility methods for indexing peaks and finding the UB matrix. </p>
<dl class="section author"><dt>Author</dt><dd>Dennis Mikkelson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2011-06-14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/de5/IndexingUtils_8h_source.html#l00032">32</a> of file <a class="el" href="../../d8/de5/IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aea5372b634886144fd40b4d1dcbc3372" name="aea5372b634886144fd40b4d1dcbc3372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5372b634886144fd40b4d1dcbc3372">&#9670;&#160;</a></span>CalculateMillerIndices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">V3D</a> IndexingUtils::CalculateMillerIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>inverseUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>q_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a UB, calculate the miller indices for given q vector. </p>
<p >Calculate the Miller Indices for the specified Q vector, using the inverse of the specified UB matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverseUB</td><td>A 3x3 matrix of doubles holding the inverse UB matrix. The matrix is not checked for validity </td></tr>
    <tr><td class="paramname">q_vector</td><td>V3D object containing Q vector in sample frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indexes of the given peak. They have not been tested for validity </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02366">2366</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

</div>
</div>
<a id="ace3ee81a1b10f0679fb5de679f581722" name="ace3ee81a1b10f0679fb5de679f581722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3ee81a1b10f0679fb5de679f581722">&#9670;&#160;</a></span>CalculateMillerIndices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::CalculateMillerIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>inverseUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>q_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>miller_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a UB, calculate the miller indices for given q vector. </p>
<p >Calculate the Miller Indices for the specified Q vector, using the inverse of the specified UB matrix.</p>
<p >If the peak could not be indexed it is set to (0,0,0)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverseUB</td><td>A 3x3 matrix of doubles holding the inverse UB matrix. The matrix is not checked for validity </td></tr>
    <tr><td class="paramname">q_vector</td><td>std::vector of V3D objects that contains the list of q_vectors that are to be indexed. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum allowed distance between each component of UB^(-1)*Q and the nearest integer value, required to to count the peak as indexed by UB. </td></tr>
    <tr><td class="paramname">miller_indices</td><td>This vector returns a list of Miller Indices, with one entry for each given Q vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the peak was index, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02344">2344</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02294">CalculateMillerIndices()</a>, <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">ValidIndex()</a>.</p>

</div>
</div>
<a id="aff851f0a060ce19e3e703abe3e941634" name="aff851f0a060ce19e3e703abe3e941634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff851f0a060ce19e3e703abe3e941634">&#9670;&#160;</a></span>CalculateMillerIndices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::CalculateMillerIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>miller_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ave_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a UB, get list of Miller indices for specifed Qs and tolerance. </p>
<p >Calculate the Miller Indices for each of the specified Q vectors, using the inverse of the specified UB matrix.</p>
<p >The Miller Indices will be set to 0, 0, 0 for any peak for which h, k or l differs from an intenger by more than the specified tolerance. Also (h,k,l) = (0,0,0) the peak will NOT be counted as indexed, since (0,0,0) is not a valid index of any peak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>A 3x3 matrix of doubles holding the UB matrix </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are to be indexed. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum allowed distance between each component of UB^(-1)*Q and the nearest integer value, required to to count the peak as indexed by UB. </td></tr>
    <tr><td class="paramname">miller_indices</td><td>This vector returns a list of Miller Indices, with one entry for each given Q vector. </td></tr>
    <tr><td class="paramname">ave_error</td><td>The average error from all lattice directions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative integer giving the number of peaks indexed by UB, within the specified tolerance on h,k,l.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the UB matrix is not a 3X3 matrix, or if UB is singular. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02294">2294</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02294">CalculateMillerIndices()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">CheckUB()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00037">count</a>, <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00530">Mantid::Kernel::V3D::hklError()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00924">Mantid::Kernel::Matrix&lt; T &gt;::Invert()</a>, and <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/d7c/SelectCellWithForm_8cpp_source.html#l00104">Mantid::Crystal::SelectCellWithForm::ApplyTransform()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02294">CalculateMillerIndices()</a>, <a class="el" href="../../d8/dc5/ConvertCWSDMDtoHKL_8cpp_source.html#l00253">Mantid::MDAlgorithms::ConvertCWSDMDtoHKL::convertFromQSampleToHKL()</a>, and <a class="el" href="../../d3/dac/FindUBUsingIndexedPeaks_8cpp_source.html#l00040">Mantid::Crystal::FindUBUsingIndexedPeaks::exec()</a>.</p>

</div>
</div>
<a id="a8c022eae677abc18940c7bfcbc88a5f7" name="a8c022eae677abc18940c7bfcbc88a5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c022eae677abc18940c7bfcbc88a5f7">&#9670;&#160;</a></span>CheckUB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::CheckUB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the specified UB is reasonable for an orientation matrix. </p>
<p >Check whether or not the specified matrix is reasonable for an orientation matrix.</p>
<p >In particular, check that it is a 3x3 matrix without any nan or infinite values and that its determinant is within a reasonable range, for an orientation matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>A 3x3 matrix of doubles holding the UB matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this could be a valid UB matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">2136</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l01048">Mantid::Kernel::Matrix&lt; T &gt;::determinant()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, and <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02294">CalculateMillerIndices()</a>, <a class="el" href="../../d3/dda/CalculatePeaksHKL_8cpp_source.html#l00048">Mantid::Crystal::CalculatePeaksHKL::exec()</a>, <a class="el" href="../../db/dac/FindUBUsingFFT_8cpp_source.html#l00052">Mantid::Crystal::FindUBUsingFFT::exec()</a>, <a class="el" href="../../d3/dac/FindUBUsingIndexedPeaks_8cpp_source.html#l00040">Mantid::Crystal::FindUBUsingIndexedPeaks::exec()</a>, <a class="el" href="../../d3/d19/FindUBUsingLatticeParameters_8cpp_source.html#l00056">Mantid::Crystal::FindUBUsingLatticeParameters::exec()</a>, <a class="el" href="../../dd/d7d/FindUBUsingMinMaxD_8cpp_source.html#l00068">Mantid::Crystal::FindUBUsingMinMaxD::exec()</a>, <a class="el" href="../../d6/d09/SelectCellOfType_8cpp_source.html#l00073">Mantid::Crystal::SelectCellOfType::exec()</a>, <a class="el" href="../../d0/d7c/SelectCellWithForm_8cpp_source.html#l00156">Mantid::Crystal::SelectCellWithForm::exec()</a>, <a class="el" href="../../db/d13/ShowPossibleCells_8cpp_source.html#l00049">Mantid::Crystal::ShowPossibleCells::exec()</a>, <a class="el" href="../../d7/df5/TransformHKL_8cpp_source.html#l00072">Mantid::Crystal::TransformHKL::exec()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02534">GetIndexedPeaks()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02096">IndexingError()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02175">NumberIndexed()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00886">Optimize_6dUB()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00644">Optimize_UB()</a>.</p>

</div>
</div>
<a id="a2d4400ab417ec6dc3477f8c43e4eef78" name="a2d4400ab417ec6dc3477f8c43e4eef78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4400ab417ec6dc3477f8c43e4eef78">&#9670;&#160;</a></span>DiscardDuplicates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexingUtils::DiscardDuplicates </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>len_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ang_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a sublist of the specified list of a,b,c directions, by removing all directions that seem to be duplicates. </p>
<p >If several directions all have the same length (within the specified length tolerance) and have the same direction (within the specified angle tolerange) then only one of those directions will be recorded in the sublist. The one that indexes the most peaks, within the specified tolerance will be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_list</td><td>This vector will be cleared and filled with the vectors from the directions list that are not duplicates of other vectors in the list. </td></tr>
    <tr><td class="paramname">directions</td><td>Input list of possible a,b,c directions, listed in order of increasing vector norm. This list will be cleared by this method. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>List of q_vectors that should be indexed </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The tolerance for indexing </td></tr>
    <tr><td class="paramname">len_tol</td><td>The tolerance on the relative difference in length for two directions to be considered equal. Eg. if relative differences must be less than 5% for two lengths to be considered the same, pass in .05 for the len_tol. </td></tr>
    <tr><td class="paramname">ang_tol</td><td>The tolerance for the difference in directions, specified in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01925">1925</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00165">Mantid::Kernel::V3D::angle()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00263">Mantid::Kernel::V3D::norm()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02213">NumberIndexed_1D()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>.</p>

</div>
</div>
<a id="a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8" name="a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbdb7e17d30f3bd6bcc93f6dc5f6ed8">&#9670;&#160;</a></span>FFTScanFor_Directions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t IndexingUtils::FFTScanFor_Directions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees_per_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use FFT to get list of possible directions and lengths for real space unit cell. </p>
<p >Get list of possible edge vectors for the real space unit cell.</p>
<p >This method uses FFTs to find directions for which projections of the peaks on those directions have repetitive patterns. This list of directions found will consist of vectors, V, for which V dot Q is essentially an integer for the most Q vectors. The difference between V dot Q and an integer must be less than the required tolerance for it to count as an integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directions</td><td>Vector that will be filled with the directions that may correspond to unit cell edges. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>Vector of new Vector3D objects that contains the list of q_vectors that are to be indexed. </td></tr>
    <tr><td class="paramname">min_d</td><td>Lower bound on shortest unit cell edge length. This does not have to be specified exactly but must be strictly less than the smallest edge length, in Angstroms. </td></tr>
    <tr><td class="paramname">max_d</td><td>Upper bound on longest unit cell edge length. This does not have to be specified exactly but must be strictly more than the longest edge length in angstroms. </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed deviation of Miller indices from integer values for a peak to be indexed. </td></tr>
    <tr><td class="paramname">degrees_per_step</td><td>The number of degrees between directions that are checked while scanning for an initial indexing of the peaks with lowest |Q|. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">1415</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00483">Mantid::Kernel::V3D::compareMagnitude()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00037">count</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01925">DiscardDuplicates()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01646">GetFirstMaxIndex()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02398">GetIndexedPeaks_1D()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01600">GetMagFFT()</a>, <a class="el" href="../../d1/d0a/Kernel_2src_2DeltaEMode_8cpp_source.html#l00019">index</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02594">MakeHemisphereDirections()</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00263">Mantid::Kernel::V3D::norm()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02213">NumberIndexed_1D()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01027">Optimize_Direction()</a>, and <a class="el" href="../../d6/d64/GetAllEi_8cpp_source.html#l00154">position</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00451">Find_UB()</a>.</p>

</div>
</div>
<a id="a3a6be7480a624d2226ee3147b9c962be" name="a3a6be7480a624d2226ee3147b9c962be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6be7480a624d2226ee3147b9c962be">&#9670;&#160;</a></span>Find_UB() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Find_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees_per_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the UB matrix that most nearly indexes the specified qxyz values using FFTs, given the range of possible real space unit cell edge lengths. </p>
<p >STATIC method Find_UB: This method will attempt to calculate the matrix that most nearly indexes the specified q_vectors, using FFTs to find patterns in projected Q-vectors, given only a range of possible unit cell edge lengths.</p>
<p >If successful, the resulting matrix should correspond to the Niggli reduced cell. The resolution of the search through possible orientations is specified by the degrees_per_step parameter. One to two degrees per step is usually adequate. NOTE: The execution time is O(n^3) where n is the number of degrees per step, so decreasing the resolution to 0.5 degree per step will take about 8 times longer than using 1 degree per step. It should not be necessary to decrease this value below 1 degree per step, and users will have to be VERY patient, if it is decreased much below 1 degree per step. The specified q_vectors should correspond to a single crystal, for this to work reliably.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are to be indexed NOTE: There must be at least 4 q_vectors and it really should have at least 10 or more peaks for this to work quite consistently. </td></tr>
    <tr><td class="paramname">min_d</td><td>Lower bound on shortest unit cell edge length. This does not have to be specified exactly but must be strictly less than the smallest edge length, in Angstroms. </td></tr>
    <tr><td class="paramname">max_d</td><td>Upper bound on longest unit cell edge length. This does not have to be specified exactly but must be strictly more than the longest edge length in angstroms. </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed deviation of Miller indices from integer values for a peak to be indexed. </td></tr>
    <tr><td class="paramname">degrees_per_step</td><td>The number of degrees between different orientations used during the initial scan. </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of refinements of UB</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if UB is not a 3X3 matrix, if there are not at least 3 q vectors, if min_d &gt;= max_d or min_d &lt;= 0, if the required_tolerance or degrees_per_step is &lt;= 0, if at least three possible a,b,c directions were not found, or if a valid UB matrix could not be formed from the a,b,c directions that were found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00451">451</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00483">Mantid::Kernel::V3D::compareMagnitude()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01709">FormUB_From_abc_Vectors()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02534">GetIndexedPeaks()</a>, <a class="el" href="../../dc/d6a/NiggliCell_8cpp_source.html#l00183">Mantid::Geometry::NiggliCell::MakeNiggliUB()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">Optimize_UB()</a>.</p>

</div>
</div>
<a id="aa0d478cd51f5db419ca954b57584f692" name="aa0d478cd51f5db419ca954b57584f692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d478cd51f5db419ca954b57584f692">&#9670;&#160;</a></span>Find_UB() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Find_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees_per_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the UB matrix that most nearly indexes the specified qxyz values given the range of possible real space unit cell edge lengths. </p>
<p >STATIC method Find_UB: This method will attempt to calculate the matrix that most nearly indexes the specified q_vectors, given only a range of possible unit cell edge lengths.</p>
<p >If successful, the matrix should correspond to the Niggli reduced cell. The resolution of the search through possible orientations is specified by the degrees_per_step parameter. Approximately 1-3 degrees_per_step is usually adequate. NOTE: This is an expensive calculation which takes approximately 1 second using 1 degree_per_step. However, the execution time is O(n^3) so decreasing the resolution to 0.5 degree per step will take about 8 seconds, etc. It should not be necessary to decrease this value below 1 degree per step, and users will have to be VERY patient, if it is decreased much below 1 degree per step. The number of peaks used to obtain an initial indexing is specified by the "NumInitial" parameter. Good values for this are typically around 15-25. The specified q_vectors must correspond to a single crystal. If several crystallites are present or there are other sources of "noise" leading to invalid peaks, this method will not work well. The method that uses lattice parameters may be better in such cases. Alternatively, adjust the list of specified q_vectors so it does not include noise peaks or peaks from more than one crystal, by increasing the threshold for what counts as a peak, or by other methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are to be indexed NOTE: There must be at least 3 q_vectors. </td></tr>
    <tr><td class="paramname">min_d</td><td>Lower bound on shortest unit cell edge length. This does not have to be specified exactly but must be strictly less than the smallest edge length, in Angstroms. </td></tr>
    <tr><td class="paramname">max_d</td><td>Upper bound on longest unit cell edge length. This does not have to be specified exactly but must be strictly more than the longest edge length in angstroms. </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed deviation of Miller indices from integer values for a peak to be indexed. </td></tr>
    <tr><td class="paramname">base_index</td><td>The sequence number of the peak that should be used as the central peak. On the first scan for a UB matrix that fits the data, the remaining peaks in the list of q_vectors will be shifted by -base_peak, where base_peak is the q_vector with the specified base index. If fewer than 6 peaks are specified in the q_vectors list, this parameter is ignored. If this parameter is -1, and there are at least five peaks in the q_vector list, then a base index will be calculated internally. In most cases, it should suffice to set this to -1. </td></tr>
    <tr><td class="paramname">num_initial</td><td>The number of low |Q| peaks that should be used to scan for an initial orientation matrix. </td></tr>
    <tr><td class="paramname">degrees_per_step</td><td>The number of degrees between different orientations used during the initial scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if UB is not a 3X3 matrix, if there are not at least 3 q vectors, if min_d &gt;= max_d or min_d &lt;= 0 if num_initial is &lt; 3, or if the required_tolerance or degrees_per_step is &lt;= 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00277">277</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00483">Mantid::Kernel::V3D::compareMagnitude()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01709">FormUB_From_abc_Vectors()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02534">GetIndexedPeaks()</a>, <a class="el" href="../../dc/d6a/NiggliCell_8cpp_source.html#l00183">Mantid::Geometry::NiggliCell::MakeNiggliUB()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">Optimize_UB()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01297">ScanFor_Directions()</a>.</p>

</div>
</div>
<a id="a5f2c90b22c0ead5a4c3f2b7d9f51ad19" name="a5f2c90b22c0ead5a4c3f2b7d9f51ad19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2c90b22c0ead5a4c3f2b7d9f51ad19">&#9670;&#160;</a></span>Find_UB() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Find_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/ded/classMantid_1_1Geometry_1_1OrientedLattice.html">OrientedLattice</a> &amp;&#160;</td>
          <td class="paramname"><em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees_per_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixAll</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the UB matrix that most nearly indexes the specified qxyz values given the lattice parameters. </p>
<p >STATIC method Find_UB: Calculates the matrix that most nearly indexes the specified q_vectors, given the lattice parameters.</p>
<p >The sum of the squares of the residual errors is returned. This method first sorts the specified q_vectors in order of increasing magnitude. It then searches through all possible orientations to find an initial UB that indexes the lowest magnitude peaks. The resolution of the search through possible orientations is specified by the degrees_per_step parameter. Approximately 2-4 degrees_per_step is usually adequate. NOTE: This is an expensive calculation which takes approximately 1 second using 2 degrees_per_step. However, the execution time is O(n^3) so decreasing the resolution to 1 degree per step will take about 8 seconds, etc. It should not be necessary to decrease this value below 1 degree per step, and users will have to be VERY patient, if it is decreased much below 1 degree per step. The number of peaks used to obtain an initial indexing is specified by the "NumInitial" parameter. Good values for this are typically around 10-15, though with accurate peak positions, and good values for the lattice paramters, as few as 2 can be used. Using substantially more than 15 peaks initially typically has no benefit and increases execution time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are to be indexed NOTE: There must be at least 2 q_vectors. </td></tr>
    <tr><td class="paramname">lattice</td><td>The orientated lattice with the lattice parameters a,b,c and alpha, beta, gamma. The found UB and errors will be set on this lattice. </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed deviation of Miller indices from integer values for a peak to be indexed. </td></tr>
    <tr><td class="paramname">base_index</td><td>The sequence number of the peak that should be used as the central peak. On the first scan for a UB matrix that fits the data, the remaining peaks in the list of q_vectors will be shifted by -base_peak, where base_peak is the q_vector with the specified base index. If fewer than 5 peaks are specified in the q_vectors list, this parameter is ignored. If this parameter is -1, and there are at least four peaks in the q_vector list, then a base index will be calculated internally. In most cases, it should suffice to set this to -1. </td></tr>
    <tr><td class="paramname">num_initial</td><td>The number of low |Q| peaks that should be used to scan for an initial orientation matrix. </td></tr>
    <tr><td class="paramname">degrees_per_step</td><td>The number of degrees between different orientations used during the initial scan. </td></tr>
    <tr><td class="paramname">fixAll</td><td>Fix the lattice parameters and do not optimise the UB matrix. </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of refinements of UB</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if UB is not a 3X3 matrix, if there are not at least 2 q vectors, if num_initial is &lt; 2, or if the required_tolerance or degrees_per_step is &lt;= 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00094">94</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00483">Mantid::Kernel::V3D::compareMagnitude()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02534">GetIndexedPeaks()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">Optimize_UB()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01134">ScanFor_UB()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00325">Mantid::Geometry::UnitCell::setError()</a>, and <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00115">Mantid::Geometry::OrientedLattice::setUB()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dac/FindUBUsingFFT_8cpp_source.html#l00052">Mantid::Crystal::FindUBUsingFFT::exec()</a>, <a class="el" href="../../d3/d19/FindUBUsingLatticeParameters_8cpp_source.html#l00056">Mantid::Crystal::FindUBUsingLatticeParameters::exec()</a>, and <a class="el" href="../../dd/d7d/FindUBUsingMinMaxD_8cpp_source.html#l00068">Mantid::Crystal::FindUBUsingMinMaxD::exec()</a>.</p>

</div>
</div>
<a id="a549b59187425e0b6ebcec437244b4e5b" name="a549b59187425e0b6ebcec437244b4e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549b59187425e0b6ebcec437244b4e5b">&#9670;&#160;</a></span>FormUB_From_abc_Vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::FormUB_From_abc_Vectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>req_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Form a UB matrix by choosing three vectors from list of possible a,b,c to maximize the number of peaks indexed and minimize cell volume. </p>
<p >Form a UB matrix from the given list of possible directions, using the three directions that correspond to a unit cell with the smallest volume (greater than or equal to the specified minimum volume) that indexes at least 80% of the maximum number of peaks indexed by any set of three distinct vectors chosen from the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>The calculated UB matrix will be returned in this parameter </td></tr>
    <tr><td class="paramname">directions</td><td>List of possible vectors for a, b, c. This list MUST be sorted in order of increasing magnitude. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>The list of q_vectors that should be indexed </td></tr>
    <tr><td class="paramname">req_tolerance</td><td>The required tolerance on h,k,l to consider a peak to be indexed. </td></tr>
    <tr><td class="paramname">min_vol</td><td>The smallest possible unit cell volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a UB matrix was set, and false if it not possible to choose a,b,c (i.e. UB) from the list of directions, starting with the specified a_index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the UB matrix is not a 3X3 matrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the matrix inversion fails and UB can't be formed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01809">1809</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00278">Mantid::Kernel::V3D::cross_prod()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00285">Mantid::Geometry::OrientedLattice::GetUB()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02251">NumberIndexed_3D()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, and <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>.</p>

</div>
</div>
<a id="adf44e7052344de6324e5d8b7096ff927" name="adf44e7052344de6324e5d8b7096ff927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf44e7052344de6324e5d8b7096ff927">&#9670;&#160;</a></span>FormUB_From_abc_Vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::FormUB_From_abc_Vectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to form a UB matrix from three vectors chosen from list of possible a,b,c directions, starting with the a vector at the given index. </p>
<p >Form a UB matrix from the given list of possible directions, using the direction at the specified index for the "a" direction.</p>
<p >The "b" and "c" directions are chosen so that 1) |a| &lt; |b| &lt; |c|, 2) the angle between the a, b, c, vectors is at least a minimum angle based on min_d/max_d 3) c is not in the same plane as a and b.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>The calculated UB matrix will be returned in this parameter </td></tr>
    <tr><td class="paramname">directions</td><td>List of possible vectors for a, b, c. This list MUST be sorted in order of increasing magnitude. </td></tr>
    <tr><td class="paramname">a_index</td><td>The index to use for the a vector. The b and c vectors will be choosen from LATER positions in the directions list. </td></tr>
    <tr><td class="paramname">min_d</td><td>Minimum possible real space unit cell edge length. </td></tr>
    <tr><td class="paramname">max_d</td><td>Maximum possible real space unit cell edge length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a UB matrix was set, and false if it not possible to choose a,b,c (i.e. UB) from the list of directions, starting with the specified a_index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the UB matrix is not a 3X3 matrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the matrix inversion fails and UB can't be formed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01709">1709</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00165">Mantid::Kernel::V3D::angle()</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00278">Mantid::Kernel::V3D::cross_prod()</a>, <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00285">Mantid::Geometry::OrientedLattice::GetUB()</a>, <a class="el" href="../../d1/d0a/Kernel_2src_2DeltaEMode_8cpp_source.html#l00019">index</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00341">Mantid::Kernel::normalize()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, and <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00277">Find_UB()</a>.</p>

</div>
</div>
<a id="a4a1d31c539bf744a2aa6b4110f6df845" name="a4a1d31c539bf744a2aa6b4110f6df845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1d31c539bf744a2aa6b4110f6df845">&#9670;&#160;</a></span>GetFirstMaxIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::GetFirstMaxIndex </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>magnitude_fft</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the location of the first maximum (beyond the DC term) in the |FFT| that exceeds the specified threshold. </p>
<p >Scan the FFT array for the first maximum that exceeds the specified threshold and is beyond the initial DC term/interval.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">magnitude_fft</td><td>The array containing the magnitude of the FFT values. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the FFT array. </td></tr>
    <tr><td class="paramname">threshold</td><td>The required threshold for the first peak. This must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The centroid (index) where the first maximum occurs, or -1 if no point in the FFT (beyond the DC term) equals or exceeds the required threshold. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01646">1646</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>.</p>

</div>
</div>
<a id="a07ab133289f37fcd1f81e7f79bfc8c0f" name="a07ab133289f37fcd1f81e7f79bfc8c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ab133289f37fcd1f81e7f79bfc8c0f">&#9670;&#160;</a></span>GetIndexedPeaks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::GetIndexedPeaks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>miller_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexed_qs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fit_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get lists of indices and Qs for peaks indexed by the specified UB matrix. </p>
<p >Given a list of peak positions and a UB matrix, get the list of Miller indices and corresponding peak positions for the peaks that are indexed to within a specified tolerance, by the UB matrix.</p>
<p >This method is similar to GetIndexedPeaks_3D, but directly uses the inverse of the UB matrix to map Q -&gt; hkl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>The UB matrix that determines the indexing of the peaks. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>List of V3D peaks in reciprocal space </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed error (as a faction of the corresponding Miller index) for a peak q_vector to be counted as indexed. </td></tr>
    <tr><td class="paramname">miller_indices</td><td>List of the Miller indices (h,k,l) of peaks that were indexed in all specified directions. </td></tr>
    <tr><td class="paramname">indexed_qs</td><td>List of Qxyz value for the peaks that were indexed indexed in all specified directions. </td></tr>
    <tr><td class="paramname">fit_error</td><td>The sum of the squares of the distances from integer values for the UB*Q for the specified UB matrix and the specified q_vectors. This is a measure of the error in <a class="el" href="../../db/dc5/classMantid_1_1Geometry_1_1HKL.html" title="HKL : HKL MDFrame.">HKL</a> space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of q_vectors that are indexed to within the specified tolerance, in the specified direction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02534">2534</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">CheckUB()</a>, <a class="el" href="../../dc/dd8/IndexPeaks_8cpp_source.html#l00133">error</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00924">Mantid::Kernel::Matrix&lt; T &gt;::Invert()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">ValidIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/d7c/SelectCellWithForm_8cpp_source.html#l00051">Mantid::Crystal::SelectCellWithForm::DetermineErrors()</a>, <a class="el" href="../../db/dac/FindUBUsingFFT_8cpp_source.html#l00052">Mantid::Crystal::FindUBUsingFFT::exec()</a>, <a class="el" href="../../dd/d7d/FindUBUsingMinMaxD_8cpp_source.html#l00068">Mantid::Crystal::FindUBUsingMinMaxD::exec()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00094">Find_UB()</a>.</p>

</div>
</div>
<a id="a4d2cc14be6d3d9c68c38136b423e45bb" name="a4d2cc14be6d3d9c68c38136b423e45bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2cc14be6d3d9c68c38136b423e45bb">&#9670;&#160;</a></span>GetIndexedPeaks_1D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::GetIndexedPeaks_1D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexed_qs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fit_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get lists of indices and Qs for peaks indexed in the specified direction. </p>
<p >Given one plane normal direction for a family of parallel planes in reciprocal space, find the peaks that lie on these planes to within the specified tolerance.</p>
<p >The direction is specified as a vector with length "a" if the plane spacing in reciprocal space is 1/a. In that way, the dot product of a peak Qxyz with the direction vector will be an integer if the peak lies on one of the planes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>Direction vector in the direction of the normal vector for a family of parallel planes in reciprocal space. The length of this vector must be the reciprocal of the plane spacing. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>List of V3D peaks in reciprocal space </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed error (as a faction of the corresponding Miller index) for a peak q_vector to be counted as indexed. </td></tr>
    <tr><td class="paramname">index_vals</td><td>List of the one-dimensional Miller indices peaks that were indexed in the specified direction. </td></tr>
    <tr><td class="paramname">indexed_qs</td><td>List of Qxyz value for the peaks that were indexed indexed in the specified direction. </td></tr>
    <tr><td class="paramname">fit_error</td><td>The sum of the squares of the distances from integer values for the projections of the indexed q_vectors on the specified direction. This is a measure of the error in <a class="el" href="../../db/dc5/classMantid_1_1Geometry_1_1HKL.html" title="HKL : HKL MDFrame.">HKL</a> space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of q_vectors that are indexed to within the specified tolerance, in the specified direction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02398">2398</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd8/IndexPeaks_8cpp_source.html#l00133">error</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00263">Mantid::Kernel::V3D::norm()</a>, and <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01297">ScanFor_Directions()</a>.</p>

</div>
</div>
<a id="aa01b311ee9931c8fd4583ebff5ae8cd6" name="aa01b311ee9931c8fd4583ebff5ae8cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01b311ee9931c8fd4583ebff5ae8cd6">&#9670;&#160;</a></span>GetIndexedPeaks_3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::GetIndexedPeaks_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>direction_3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>miller_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexed_qs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fit_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get lists of indices and Qs for peaks indexed in three given directions. </p>
<p >Given three plane normal directions for three families of parallel planes in reciprocal space, find the peaks that lie on these planes to within the specified tolerance.</p>
<p >The three directions are specified as vectors with lengths that are the reciprocals of the corresponding plane spacings. In that way, the dot product of a peak Qxyz with one of the direction vectors will be an integer if the peak lies on one of the planes corresponding to that direction. If the three directions are properly chosen to correspond to the unit cell edges, then the resulting indices will be proper Miller indices for the peaks. This method is similar to GetIndexedPeaks_1D, but checks three directions simultaneously and requires that the peak lies on all three families of planes simultaneously and does NOT index as (0,0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction_1</td><td>Direction vector in the direction of the normal vector for the first family of parallel planes. </td></tr>
    <tr><td class="paramname">direction_2</td><td>Direction vector in the direction of the normal vector for the second family of parallel planes. </td></tr>
    <tr><td class="paramname">direction_3</td><td>Direction vector in the direction of the normal vector for the third family of parallel planes. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>List of V3D peaks in reciprocal space </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed error (as a faction of the corresponding Miller index) for a peak q_vector to be counted as indexed. </td></tr>
    <tr><td class="paramname">miller_indices</td><td>List of the Miller indices (h,k,l) of peaks that were indexed in all specified directions. </td></tr>
    <tr><td class="paramname">indexed_qs</td><td>List of Qxyz value for the peaks that were indexed indexed in all specified directions. </td></tr>
    <tr><td class="paramname">fit_error</td><td>The sum of the squares of the distances from integer values for the projections of the indexed q_vectors on the specified directions. This is a measure of the error in <a class="el" href="../../db/dc5/classMantid_1_1Geometry_1_1HKL.html" title="HKL : HKL MDFrame.">HKL</a> space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of q_vectors that are indexed to within the specified tolerance, in the specified direction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02464">2464</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">ValidIndex()</a>.</p>

</div>
</div>
<a id="afd121b4386108f902cae3f0a42da7d89" name="afd121b4386108f902cae3f0a42da7d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd121b4386108f902cae3f0a42da7d89">&#9670;&#160;</a></span>GetLatticeParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::GetLatticeParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lattice_par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the lattice parameters for the specified orientation matrix. </p>
<p >Get the lattice parameters, a, b, c, alpha, beta, gamma and cell volume for the specified orientation matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>A non-singular matrix representing an orientation matrix. </td></tr>
    <tr><td class="paramname">lattice_par</td><td>std::vector of doubles that will contain the lattice parameters and cell volume as it's first seven entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lattice_par vector was filled with the lattice parameters and false if the matrix could not be inverted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02780">2780</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00094">Mantid::Geometry::UnitCell::a()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00133">Mantid::Geometry::UnitCell::alpha()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00123">Mantid::Geometry::UnitCell::b()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00138">Mantid::Geometry::UnitCell::beta()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00128">Mantid::Geometry::UnitCell::c()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00143">Mantid::Geometry::UnitCell::gamma()</a>, <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00115">Mantid::Geometry::OrientedLattice::setUB()</a>, and <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00737">Mantid::Geometry::UnitCell::volume()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d16/ConventionalCell_8cpp_source.html#l00033">Mantid::Geometry::ConventionalCell::ConventionalCell()</a>, <a class="el" href="../../d4/d46/OptimizeLatticeForCellType_8cpp_source.html#l00072">Mantid::Crystal::OptimizeLatticeForCellType::exec()</a>, <a class="el" href="../../d5/d40/ScalarUtils_8cpp_source.html#l00217">Mantid::Geometry::ScalarUtils::GetCellForForm()</a>, <a class="el" href="../../d5/d40/ScalarUtils_8cpp_source.html#l00182">Mantid::Geometry::ScalarUtils::GetCellsUBOnly()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02838">GetLatticeParameterString()</a>, <a class="el" href="../../d6/d16/ConventionalCell_8cpp_source.html#l00101">Mantid::Geometry::ConventionalCell::GetSumOfSides()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00770">Optimize_6dUB()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">Optimize_UB()</a>.</p>

</div>
</div>
<a id="a3217dc6ad7f59c197478afc443654021" name="a3217dc6ad7f59c197478afc443654021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3217dc6ad7f59c197478afc443654021">&#9670;&#160;</a></span>GetLatticeParameterString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IndexingUtils::GetLatticeParameterString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a formatted string listing the lattice parameters and cell volume. </p>
<p >Get a nicely formatted string listing the lattice parameters and cell volume.</p>
<dl class="section return"><dt>Returns</dt><dd>a string listing the cell parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02838">2838</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02780">GetLatticeParameters()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d09/SelectCellOfType_8cpp_source.html#l00073">Mantid::Crystal::SelectCellOfType::exec()</a>, <a class="el" href="../../d0/d7c/SelectCellWithForm_8cpp_source.html#l00156">Mantid::Crystal::SelectCellWithForm::exec()</a>, and <a class="el" href="../../db/d13/ShowPossibleCells_8cpp_source.html#l00049">Mantid::Crystal::ShowPossibleCells::exec()</a>.</p>

</div>
</div>
<a id="aa903e7be897186dc66b402ece32b39c2" name="aa903e7be897186dc66b402ece32b39c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa903e7be897186dc66b402ece32b39c2">&#9670;&#160;</a></span>GetMagFFT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::GetMagFFT </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>current_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projections</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>index_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>magnitude_fft</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the magnitude of the FFT of the projections of the q_vectors on the current direction vector. </p>
<p >Fill an array with the magnitude of the FFT of the projections of the specified q_vectors on the specified direction.</p>
<p >The largest value in the magnitude FFT that occurs at index 5 or more is returned as the value of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_vectors</td><td>The list of Q vectors to project on the specified direction. </td></tr>
    <tr><td class="paramname">current_dir</td><td>The direction the Q vectors will be projected on. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the projections[] array. This MUST BE a power of 2. The magnitude_fft[] array must be half the size. </td></tr>
    <tr><td class="paramname">projections</td><td>Array to hold the projections of the Q vectors. This must be long enough so that all projected values map map to a valid index, after they are multiplied by the index_factor. </td></tr>
    <tr><td class="paramname">index_factor</td><td>Factor that when multiplied by a projected Q vector will give a valid index into the projections array. </td></tr>
    <tr><td class="paramname">magnitude_fft</td><td>Array that will be filled out with the magnitude of the FFT of the projections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest value in the magnitude_fft, that is stored in position 5 or more. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01600">1600</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../d1/d0a/Kernel_2src_2DeltaEMode_8cpp_source.html#l00019">index</a>, and <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>.</p>

</div>
</div>
<a id="abbc686ed5572dcece833f858acaef747" name="abbc686ed5572dcece833f858acaef747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc686ed5572dcece833f858acaef747">&#9670;&#160;</a></span>GetModulationVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::GetModulationVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ModUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>ModVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02819">2819</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00535">Mantid::Geometry::UnitCell::getModVec()</a>, <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00132">Mantid::Geometry::OrientedLattice::setModUB()</a>, and <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00115">Mantid::Geometry::OrientedLattice::setUB()</a>.</p>

</div>
</div>
<a id="a1825d45a3db416fd213b22fee98e1934" name="a1825d45a3db416fd213b22fee98e1934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1825d45a3db416fd213b22fee98e1934">&#9670;&#160;</a></span>GetModulationVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::GetModulationVectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ModUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>ModVec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>ModVec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>ModVec3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02798">2798</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00555">Mantid::Geometry::UnitCell::getdh()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00562">Mantid::Geometry::UnitCell::getdk()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00569">Mantid::Geometry::UnitCell::getdl()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00535">Mantid::Geometry::UnitCell::getModVec()</a>, <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00132">Mantid::Geometry::OrientedLattice::setModUB()</a>, and <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00115">Mantid::Geometry::OrientedLattice::setUB()</a>.</p>

</div>
</div>
<a id="a1346738ddca8a39e1d9e9000f6cf0bf8" name="a1346738ddca8a39e1d9e9000f6cf0bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1346738ddca8a39e1d9e9000f6cf0bf8">&#9670;&#160;</a></span>IndexingError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::IndexingError </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the average indexing error for UB with the specified q's and hkls. </p>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02096">2096</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">CheckUB()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, and <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00924">Mantid::Kernel::Matrix&lt; T &gt;::Invert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d7/df5/TransformHKL_8cpp_source.html#l00072">Mantid::Crystal::TransformHKL::exec()</a>.</p>

</div>
</div>
<a id="a62e45be2bae7ae99fc641189f36e652d" name="a62e45be2bae7ae99fc641189f36e652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e45be2bae7ae99fc641189f36e652d">&#9670;&#160;</a></span>makeCDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">V3D</a> IndexingUtils::makeCDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>b_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosBeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sinGamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector in the direction of "c" given other unit cell information. </p>
<p >For a rotated unit cell, calculate the vector in the direction of edge "c" given two vectors a_dir and b_dir in the directions of edges "a" and "b", with lengths a and b, and the cell angles.</p>
<p >The calculation is explained in the <a class="el" href="../../d8/d8e/namespaceMantid.html" title="Helper class which provides the Collimation Length for SANS instruments.">Mantid</a> document UBMatriximplementationnotes.pdf, pg 3, Andre Savici. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_dir</td><td>V3D object with length "a" in the direction of the rotated cell edge "a" </td></tr>
    <tr><td class="paramname">b_dir</td><td>V3D object with length "b" in the direction of the rotated cell edge "b" </td></tr>
    <tr><td class="paramname">c</td><td>The length of the third cell edge, c. </td></tr>
    <tr><td class="paramname">cosAlpha</td><td>cos angle between edges b and c in radians. </td></tr>
    <tr><td class="paramname">cosBeta</td><td>cos angle between edges c and a in radians. </td></tr>
    <tr><td class="paramname">cosGamma</td><td>cos angle between edges a and b in radians. </td></tr>
    <tr><td class="paramname">sinGamma</td><td>sin angle between edges a and b in radians.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new V3D object with length "c", in the direction of the third rotated unit cell edge, "c". </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01884">1884</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d6/d0e/EigenConversionHelpers_8h_source.html#l00026">Mantid::Kernel::toV3D()</a>, and <a class="el" href="../../d6/d0e/EigenConversionHelpers_8h_source.html#l00034">Mantid::Kernel::toVector3d()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01134">ScanFor_UB()</a>.</p>

</div>
</div>
<a id="a49f70fd2c0d4eee4a4aeabbe20fea62e" name="a49f70fd2c0d4eee4a4aeabbe20fea62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f70fd2c0d4eee4a4aeabbe20fea62e">&#9670;&#160;</a></span>MakeCircleDirections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">V3D</a> &gt; IndexingUtils::MakeCircleDirections </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make list of the circle of direction vectors that form a fixed angle with the specified axis. </p>
<p >Make a list of directions, uniformly distributed around a circle, all of which form the specified angle with the specified axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_steps</td><td>The number of vectors to generate around the circle. </td></tr>
    <tr><td class="paramname">axis</td><td>The specified axis </td></tr>
    <tr><td class="paramname">angle_degrees</td><td>The specified angle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing direction vectors forming the same angle with the axis.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the number of steps is &lt;= 0, or if the axix length is 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02645">2645</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00278">Mantid::Kernel::V3D::cross_prod()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00130">Mantid::Kernel::V3D::normalize()</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00341">Mantid::Kernel::normalize()</a>, <a class="el" href="../../d4/d8e/Kernel_2src_2Quat_8cpp_source.html#l00397">Mantid::Kernel::Quat::rotate()</a>, and <a class="el" href="../../d4/d8e/Kernel_2src_2Quat_8cpp_source.html#l00114">Mantid::Kernel::Quat::setAngleAxis()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01134">ScanFor_UB()</a>.</p>

</div>
</div>
<a id="a983611c692ef0e464065682b60268efe" name="a983611c692ef0e464065682b60268efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983611c692ef0e464065682b60268efe">&#9670;&#160;</a></span>MakeHemisphereDirections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">V3D</a> &gt; IndexingUtils::MakeHemisphereDirections </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make list of direction vectors uniformly distributed over a hemisphere. </p>
<p >Make a list of directions, approximately uniformly distributed over a hemisphere, with the angular separation between direction vectors approximately 90 degrees/n_steps.</p>
<p >NOTE: This method provides a list of possible directions for plane normals for reciprocal lattice planes. This facilitates a brute force search for lattice planes with a specific spacing between planes. This will be used for finding the UB matrix, given the lattice parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_steps</td><td>The number of subdivisions in latitude in the upper hemisphere.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing directions distributed over the hemisphere with y-coordinate at least zero.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the number of steps is &lt;= 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02594">2594</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d0f/GoniometerAnglesFromPhiRotation_8cpp_source.html#l00122">Mantid::Crystal::GoniometerAnglesFromPhiRotation::exec()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01297">ScanFor_Directions()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01134">ScanFor_UB()</a>.</p>

</div>
</div>
<a id="a9754da0909c3438eb1f533803b37af97" name="a9754da0909c3438eb1f533803b37af97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754da0909c3438eb1f533803b37af97">&#9670;&#160;</a></span>NumberIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::NumberIndexed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of Q vectors that are mapped to integer indices by UB. </p>
<p >Calculate the number of Q vectors that are mapped to integer h,k,l values by UB.</p>
<p >Each of the Miller indexes, h, k and l must be within the specified tolerance of an integer, in order to count the peak as indexed. Also, if (h,k,l) = (0,0,0) the peak will NOT be counted as indexed, since (0,0,0) is not a valid index of any peak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>A 3x3 matrix of doubles holding the UB matrix. The UB matrix must not be singular. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum allowed distance between each component of UB^(-1)*Q and the nearest integer value, required to to count the peak as indexed by UB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative integer giving the number of peaks indexed by UB.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the UB matrix is not a 3X3 matrix, or if UB is singular. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02175">2175</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">CheckUB()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00037">count</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00924">Mantid::Kernel::Matrix&lt; T &gt;::Invert()</a>, <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">ValidIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/d7c/SelectCellWithForm_8cpp_source.html#l00051">Mantid::Crystal::SelectCellWithForm::DetermineErrors()</a>, <a class="el" href="../../db/dac/FindUBUsingFFT_8cpp_source.html#l00052">Mantid::Crystal::FindUBUsingFFT::exec()</a>, <a class="el" href="../../d3/dac/FindUBUsingIndexedPeaks_8cpp_source.html#l00040">Mantid::Crystal::FindUBUsingIndexedPeaks::exec()</a>, <a class="el" href="../../d3/d19/FindUBUsingLatticeParameters_8cpp_source.html#l00056">Mantid::Crystal::FindUBUsingLatticeParameters::exec()</a>, and <a class="el" href="../../dd/d7d/FindUBUsingMinMaxD_8cpp_source.html#l00068">Mantid::Crystal::FindUBUsingMinMaxD::exec()</a>.</p>

</div>
</div>
<a id="a774c9ef3e1330bf6f3a637b81b741daa" name="a774c9ef3e1330bf6f3a637b81b741daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774c9ef3e1330bf6f3a637b81b741daa">&#9670;&#160;</a></span>NumberIndexed_1D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::NumberIndexed_1D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of Q vectors that map to an integer index in one direction. </p>
<p >Calculate the number of Q vectors that are mapped to a integer index value by taking the dot product with the specified direction vector.</p>
<p >The direction vector represents a possible unit cell edge vector in real space. The dot product must be within the specified tolerance of an integer, in order to count as indexed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>A V3D specifying a possible edge vector in real space. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum allowed distance to an integer from the dot products of peaks with the specified direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative integer giving the number of q-vectors indexed in one direction by the specified direction vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02213">2213</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00037">count</a>, <a class="el" href="../../dc/dd8/IndexPeaks_8cpp_source.html#l00133">error</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00263">Mantid::Kernel::V3D::norm()</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>, and <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01925">DiscardDuplicates()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>.</p>

</div>
</div>
<a id="af4430eaa5bc507c9da8d2d02f0bb1e1d" name="af4430eaa5bc507c9da8d2d02f0bb1e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4430eaa5bc507c9da8d2d02f0bb1e1d">&#9670;&#160;</a></span>NumberIndexed_3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::NumberIndexed_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>b_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>c_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of Q vectors that map to integer indices simutlaneously in three directions. </p>
<p >Calculate the number of Q vectors for which the dot product with three specified direction vectors is an integer triple, NOT equal to (0,0,0) to within the specified tolerance.</p>
<p >This give the number of peaks that would be indexed by the UB matrix formed from the specified those three real space unit cell edge vectors. NOTE: This method assumes that the three edge vectors are linearly independent and could be used to form a valid UB matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_dir</td><td>A Vector3D representing unit cell edge vector a </td></tr>
    <tr><td class="paramname">b_dir</td><td>A Vector3D representing unit cell edge vector b </td></tr>
    <tr><td class="paramname">c_dir</td><td>A Vector3D representing unit cell edge vector c </td></tr>
    <tr><td class="paramname">q_vectors</td><td>Vector of Vector3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum allowed distance to an integer from the dot products of peaks with the specified direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative integer giving the number of peaks simultaneously indexed in all three directions by the specified direction vectors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02251">2251</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00037">count</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00263">Mantid::Kernel::V3D::norm()</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>, <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">ValidIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01809">FormUB_From_abc_Vectors()</a>.</p>

</div>
</div>
<a id="a6dd6d10894c55047a3692de0683cf213" name="a6dd6d10894c55047a3692de0683cf213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd6d10894c55047a3692de0683cf213">&#9670;&#160;</a></span>NumberOfValidIndexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::NumberOfValidIndexes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>average_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find number of valid HKLs and average error, in list of HKLs. </p>
<p >Find number of valid HKLs and average error for the valid Miller indices, in a list of HKLs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hkls</td><td>List of V3D objects containing hkl values </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum acceptable deviation from integer values for the Miller indices. </td></tr>
    <tr><td class="paramname">average_error</td><td>This is set to the average error in the hkl values for the hkl values that are valid Miller indices. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02070">2070</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00037">count</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">ValidIndex()</a>.</p>

</div>
</div>
<a id="ac28ace8c20dace3d28163c7a0193021c" name="ac28ace8c20dace3d28163c7a0193021c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28ace8c20dace3d28163c7a0193021c">&#9670;&#160;</a></span>Optimize_6dUB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Optimize_6dUB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ModUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkl_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mnp_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ModDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STATIC method Optimize_6dUB: Calculates the 6-dimensional matrix that most nearly maps the specified hkl_vectors and mnp_vectors to the specified q_vectors. </p>
<p >The calculated UB minimizes the sum squared differences between UB|ModUB*(h,k,l,m,n,p) and the corresponding (qx,qy,qz) for all of the specified hklmnp and Q vectors. The sum of the squares of the residual errors is returned. This method is used to optimize the UB matrix and ModUB matrix once an initial indexing has been found.</p>
<p >ModUB matrix is a 3x3 defines the modulation vectors in Q-sample. each colomn corresponds to a modulation vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">ModUB</td><td>3x3 matrix that will be set to the ModUB matrix </td></tr>
    <tr><td class="paramname">hkl_vectors</td><td>std::vector of V3D objects that contains the list of hkl values </td></tr>
    <tr><td class="paramname">mnp_vectors</td><td>std::vector of V3D objects that contains the list of mnp values </td></tr>
    <tr><td class="paramname">ModDim</td><td>int value from 1 to 3, defines the number of dimensions of modulation. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. NOTE: The number of hkl_vectors and mnp_vectors and q_vectors must be the same, and must be at least 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual differences between the Q vectors provided and the UB*hkl values, in reciprocal space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if there are not at least 3 hkl and q vectors, or if the numbers of hkl and q vectors are not the same, or if the UB matrix is not a 3x3 matrix. or if the ModDim is not 1 or 2 or 3.</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the QR factorization fails or the UB matrix can't be calculated or if UB is a singular matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>Created by Shiyun Jin on 7/16/18. </p>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00886">886</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">CheckUB()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00686">Mantid::Kernel::Matrix&lt; T &gt;::setRow()</a>, and <a class="el" href="../../d5/d0b/FitMW_8cpp_source.html#l00051">value</a>.</p>

</div>
</div>
<a id="a054cc44a10aa645f77b4bc6706e51e73" name="a054cc44a10aa645f77b4bc6706e51e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054cc44a10aa645f77b4bc6706e51e73">&#9670;&#160;</a></span>Optimize_6dUB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Optimize_6dUB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ModUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkl_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mnp_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ModDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigabc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STATIC method Optimize_UB: Calculates the matrix that most nearly maps the specified hkl_vectors to the specified q_vectors. </p>
<p >The calculated UB minimizes the sum squared differences between UB*(h,k,l) and the corresponding (qx,qy,qz) for all of the specified hkl and Q vectors. The sum of the squares of the residual errors is returned. This method is used to optimize the UB matrix once an initial indexing has been found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">ModUB</td><td>3x3 matrix that will be set to the ModUB matrix </td></tr>
    <tr><td class="paramname">hkl_vectors</td><td>std::vector of V3D objects that contains the list of hkl values </td></tr>
    <tr><td class="paramname">mnp_vectors</td><td>std::vector of V3D objects that contains the </td></tr>
    <tr><td class="paramname">ModDim</td><td>int value from 1 to 3, defines the number of dimensions of modulation. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. </td></tr>
    <tr><td class="paramname">sigabc</td><td>error in the crystal lattice parameter values if length is at least 6. NOTE: Calculation of these errors is based on SCD FORTRAN code base at IPNS. Contributors to the least squares application(1979) are J.Marc Overhage, G.Anderson, P. C. W. Leung, R. G. Teller, and A. J. Schultz NOTE: The number of hkl_vectors and q_vectors must be the same, and must be at least 3. </td></tr>
    <tr><td class="paramname">sigq</td><td>error in the modulation vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual differences between the Q vectors provided and the UB*hkl values, in reciprocal space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if there are not at least 3 hkl and q vectors, or if the numbers of hkl and q vectors are not the same, or if the UB matrix is not a 3x3 matrix.</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the QR factorization fails or the UB matrix can't be calculated or if UB is a singular matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00770">770</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#ad86ffd71c00f26eae83f1a2107beb838a63bcabf86a9a991864777c631c5b7617">Mantid::Kernel::delta</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02780">GetLatticeParameters()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00924">Mantid::Kernel::Matrix&lt; T &gt;::Invert()</a>, <a class="el" href="../../d8/d82/Geometry_2src_2Crystal_2SpaceGroupFactory_8cpp_source.html#l00803">Mantid::Geometry::m</a>, <a class="el" href="../../d9/df2/AugmentedLagrangianOptimizer_8cpp_source.html#l00042">n</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00770">Optimize_6dUB()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dac/FindUBUsingIndexedPeaks_8cpp_source.html#l00040">Mantid::Crystal::FindUBUsingIndexedPeaks::exec()</a>, <a class="el" href="../../d8/d3b/IntegrateEllipsoidsV1_8cpp_source.html#l00306">Mantid::MDAlgorithms::IntegrateEllipsoidsV1::exec()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00770">Optimize_6dUB()</a>.</p>

</div>
</div>
<a id="a3844e70778347bb45dddc4bc1976bd99" name="a3844e70778347bb45dddc4bc1976bd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3844e70778347bb45dddc4bc1976bd99">&#9670;&#160;</a></span>Optimize_Direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Optimize_Direction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>best_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the vector that best corresponds to plane normal, given 1-D indices. </p>
<p >STATIC method Optimize_Direction: Calculates the vector for which the dot product of the the vector with each of the specified Qxyz vectors is most nearly the corresponding integer index.</p>
<p >The calculated best_vec minimizes the sum squared differences between best_vec dot (qx,qy,z) and the corresponding index for all of the specified Q vectors and indices. The sum of the squares of the residual errors is returned. NOTE: This method is similar the Optimize_UB method, but this method only optimizes the plane normal in one direction. Also, this optimizes the mapping from (qx,qy,qz) to one index (Q to index), while the Optimize_UB method optimizes the mapping from three (h,k,l) to (qx,qy,qz) (3 indices to Q).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">best_vec</td><td>V3D vector that will be set to a vector whose direction most nearly corresponds to the plane normal direction and whose magnitude is d. The corresponding plane spacing in reciprocal space is 1/d. </td></tr>
    <tr><td class="paramname">index_values</td><td>std::vector of ints that contains the list of indices </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed in one direction by the corresponding index values. NOTE: The number of index_values and q_vectors must be the same, and must be at least 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if there are not at least 3 indices and q vectors, or if the numbers of indices and q vectors are not the same.</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the QR factorization fails or the best direction can't be calculated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01027">1027</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d0b/FitMW_8cpp_source.html#l00051">value</a>, and <a class="el" href="../../d8/d82/Geometry_2src_2Crystal_2SpaceGroupFactory_8cpp_source.html#l00675">Mantid::Geometry::x</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01415">FFTScanFor_Directions()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01297">ScanFor_Directions()</a>.</p>

</div>
</div>
<a id="a884a2b3b354e4621418a3411885f8057" name="a884a2b3b354e4621418a3411885f8057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884a2b3b354e4621418a3411885f8057">&#9670;&#160;</a></span>Optimize_UB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Optimize_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkl_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the UB matrix that most nearly maps hkl to qxyz for 3 or more peaks. </p>
<p >STATIC method Optimize_UB: Calculates the matrix that most nearly maps the specified hkl_vectors to the specified q_vectors.</p>
<p >The calculated UB minimizes the sum squared differences between UB*(h,k,l) and the corresponding (qx,qy,qz) for all of the specified hkl and Q vectors. The sum of the squares of the residual errors is returned. This method is used to optimize the UB matrix once an initial indexing has been found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">hkl_vectors</td><td>std::vector of V3D objects that contains the list of hkl values </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. NOTE: The number of hkl_vectors and q_vectors must be the same, and must be at least 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual differences between the Q vectors provided and the UB*hkl values, in reciprocal space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if there are not at least 3 hkl and q vectors, or if the numbers of hkl and q vectors are not the same, or if the UB matrix is not a 3x3 matrix.</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the QR factorization fails or the UB matrix can't be calculated or if UB is a singular matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00644">644</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02136">CheckUB()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00686">Mantid::Kernel::Matrix&lt; T &gt;::setRow()</a>, and <a class="el" href="../../d5/d0b/FitMW_8cpp_source.html#l00051">value</a>.</p>

</div>
</div>
<a id="ad836b3f48459b642007618a5ebdd2f30" name="ad836b3f48459b642007618a5ebdd2f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad836b3f48459b642007618a5ebdd2f30">&#9670;&#160;</a></span>Optimize_UB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::Optimize_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkl_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigabc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the UB matrix that most nearly maps hkl to qxyz for 3 or more peaks. </p>
<p >STATIC method Optimize_UB: Calculates the matrix that most nearly maps the specified hkl_vectors to the specified q_vectors.</p>
<p >The calculated UB minimizes the sum squared differences between UB*(h,k,l) and the corresponding (qx,qy,qz) for all of the specified hkl and Q vectors. The sum of the squares of the residual errors is returned. This method is used to optimize the UB matrix once an initial indexing has been found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>3x3 matrix that will be set to the UB matrix </td></tr>
    <tr><td class="paramname">hkl_vectors</td><td>std::vector of V3D objects that contains the list of hkl values </td></tr>
    <tr><td class="paramname">q_vectors</td><td>std::vector of V3D objects that contains the list of q_vectors that are indexed by the corresponding hkl vectors. </td></tr>
    <tr><td class="paramname">sigabc</td><td>error in the crystal lattice parameter values if length is at least 6. NOTE: Calculation of these errors is based on SCD FORTRAN code base at IPNS. Contributors to the least squares application(1979) are J.Marc Overhage, G.Anderson, P. C. W. Leung, R. G. Teller, and A. J. Schultz NOTE: The number of hkl_vectors and q_vectors must be the same, and must be at least 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the sum of the squares of the residual differences between the Q vectors provided and the UB*hkl values, in reciprocal space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if there are not at least 3 hkl and q vectors, or if the numbers of hkl and q vectors are not the same, or if the UB matrix is not a 3x3 matrix.</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the QR factorization fails or the UB matrix can't be calculated or if UB is a singular matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">562</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#ad86ffd71c00f26eae83f1a2107beb838a63bcabf86a9a991864777c631c5b7617">Mantid::Kernel::delta</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02780">GetLatticeParameters()</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00924">Mantid::Kernel::Matrix&lt; T &gt;::Invert()</a>, <a class="el" href="../../d8/d82/Geometry_2src_2Crystal_2SpaceGroupFactory_8cpp_source.html#l00803">Mantid::Geometry::m</a>, <a class="el" href="../../d9/df2/AugmentedLagrangianOptimizer_8cpp_source.html#l00042">n</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">Optimize_UB()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/d7c/SelectCellWithForm_8cpp_source.html#l00051">Mantid::Crystal::SelectCellWithForm::DetermineErrors()</a>, <a class="el" href="../../db/dac/FindUBUsingFFT_8cpp_source.html#l00052">Mantid::Crystal::FindUBUsingFFT::exec()</a>, <a class="el" href="../../dd/d7d/FindUBUsingMinMaxD_8cpp_source.html#l00068">Mantid::Crystal::FindUBUsingMinMaxD::exec()</a>, <a class="el" href="../../d7/d00/IntegrateEllipsoidsTwoStep_8cpp_source.html#l00110">Mantid::MDAlgorithms::IntegrateEllipsoidsTwoStep::exec()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00094">Find_UB()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00562">Optimize_UB()</a>.</p>

</div>
</div>
<a id="a39e431c1770c959fa75499f961c495d1" name="a39e431c1770c959fa75499f961c495d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e431c1770c959fa75499f961c495d1">&#9670;&#160;</a></span>RoundHKL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexingUtils::RoundHKL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>hkl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round all the components of a <a class="el" href="../../db/dc5/classMantid_1_1Geometry_1_1HKL.html" title="HKL : HKL MDFrame.">HKL</a> objects to the nearest integer. </p>
<p >Round all of the components of the V3D to the nearest integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hkl</td><td>V3D object whose components will be rounded. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02005">2005</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02020">RoundHKLs()</a>.</p>

</div>
</div>
<a id="ab47b5d367c56d9ffaebf2874f85becd2" name="ab47b5d367c56d9ffaebf2874f85becd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47b5d367c56d9ffaebf2874f85becd2">&#9670;&#160;</a></span>RoundHKLs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexingUtils::RoundHKLs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hkl_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round all the components of a list of V3D objects, to the nearest integer. </p>
<p >Round all of the components of all vectors to the nearest integer.</p>
<p >This is useful when the vectors in the list represent Miller indices. Since the PeaksWorkspace records the Miller indices as sets of three doubles, there is no guarantee that the Miller indices will be integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hkl_list</td><td>Vector of V3D objects whose components will be rounded. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02020">2020</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02005">RoundHKL()</a>.</p>

</div>
</div>
<a id="ac83f88f8553a78bedb50f11568f9d99a" name="ac83f88f8553a78bedb50f11568f9d99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f88f8553a78bedb50f11568f9d99a">&#9670;&#160;</a></span>ScanFor_Directions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t IndexingUtils::ScanFor_Directions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees_per_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list of possible directions and lengths for real space unit cell. </p>
<p >Get list of possible edge vectors for the real space unit cell.</p>
<p >This list will consist of vectors, V, for which V dot Q is essentially an integer for the most Q vectors. The difference between V dot Q and an integer must be less than the required tolerance for it to count as an integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directions</td><td>Vector that will be filled with the directions that may correspond to unit cell edges. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>Vector of new Vector3D objects that contains the list of q_vectors that are to be indexed. </td></tr>
    <tr><td class="paramname">min_d</td><td>Lower bound on shortest unit cell edge length. This does not have to be specified exactly but must be strictly less than the smallest edge length, in Angstroms. </td></tr>
    <tr><td class="paramname">max_d</td><td>Upper bound on longest unit cell edge length. This does not have to be specified exactly but must be strictly more than the longest edge length in angstroms. </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum allowed deviation of Miller indices from integer values for a peak to be indexed. </td></tr>
    <tr><td class="paramname">degrees_per_step</td><td>The number of degrees between directions that are checked while scanning for an initial indexing of the peaks with lowest |Q|. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01297">1297</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd8/IndexPeaks_8cpp_source.html#l00133">error</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02398">GetIndexedPeaks_1D()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02594">MakeHemisphereDirections()</a>, <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00263">Mantid::Kernel::V3D::norm()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01027">Optimize_Direction()</a>, and <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00277">Find_UB()</a>.</p>

</div>
</div>
<a id="af434150dd99a9dd5b66c21cb6b31d5d3" name="af434150dd99a9dd5b66c21cb6b31d5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af434150dd99a9dd5b66c21cb6b31d5d3">&#9670;&#160;</a></span>ScanFor_UB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IndexingUtils::ScanFor_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dec/namespaceMantid_1_1Kernel.html#af7aba0cb1e2af14b7d5018cc3c22771d">Kernel::DblMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d9c/classMantid_1_1Geometry_1_1UnitCell.html">UnitCell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees_per_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan rotations to find UB that indexes peaks given lattice parameters. </p>
<p >The method uses two passes to scan across all possible directions and orientations to find the direction and orientation for the unit cell that best fits the specified list of peaks.</p>
<p >On the first pass, only those sets of directions that index the most peaks are kept. On the second pass, the directions that minimize the sum-squared deviations from integer indices are selected from that smaller set of directions. This method should be most useful if number of peaks is on the order of 10-20, and most of the peaks belong to the same crystallite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UB</td><td>This will be set to the UB matrix that best indexes the supplied list of q_vectors. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>List of locations of peaks in "Q". </td></tr>
    <tr><td class="paramname">cell</td><td>Unit cell defining the parameters a,b,c and alpha, beta, gamma. </td></tr>
    <tr><td class="paramname">degrees_per_step</td><td>The number of degrees per step used when scanning through all possible directions and orientations for the unit cell. NOTE: The work required rises very rapidly as the number of degrees per step decreases. A value of 1 degree leads to about 10 seconds of compute time. while a value of 2 only requires a bit more than 1 sec. The required time is O(n^3) where n = 1/degrees_per_step.</td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum distance from an integer that the calculated h,k,l values can have if a peak is to be considered indexed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the UB matrix is not a 3X3 matrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>exception if the matrix inversion fails and UB can't be formed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01134">1134</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00094">Mantid::Geometry::UnitCell::a()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00133">Mantid::Geometry::UnitCell::alpha()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00123">Mantid::Geometry::UnitCell::b()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00138">Mantid::Geometry::UnitCell::beta()</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00128">Mantid::Geometry::UnitCell::c()</a>, <a class="el" href="../../dc/dd8/IndexPeaks_8cpp_source.html#l00133">error</a>, <a class="el" href="../../dd/d52/Matrix_8cpp_source.html#l00022">fabs</a>, <a class="el" href="../../d8/d3d/Geometry_2src_2Crystal_2UnitCell_8cpp_source.html#l00143">Mantid::Geometry::UnitCell::gamma()</a>, <a class="el" href="../../db/d31/Geometry_2src_2Crystal_2OrientedLattice_8cpp_source.html#l00285">Mantid::Geometry::OrientedLattice::GetUB()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l01884">makeCDir()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02645">MakeCircleDirections()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02594">MakeHemisphereDirections()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00147">Mantid::Kernel::Matrix&lt; T &gt;::numCols()</a>, <a class="el" href="../../d3/db1/Matrix_8h_source.html#l00144">Mantid::Kernel::Matrix&lt; T &gt;::numRows()</a>, and <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l00094">Find_UB()</a>.</p>

</div>
</div>
<a id="a644cf2e7451072170e65c5fb6f1f0f54" name="a644cf2e7451072170e65c5fb6f1f0f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644cf2e7451072170e65c5fb6f1f0f54">&#9670;&#160;</a></span>SelectDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexingUtils::SelectDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>best_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>plane_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>required_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose the direction in a list of directions, that is most nearly perpendicular to planes with the specified spacing in reciprocal space. </p>
<p >Choose the direction vector that most nearly corresponds to a family of planes in the list of q_vectors, with spacing equal to the specified plane_spacing.</p>
<p >The direction is chosen from the specified direction_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">best_direction</td><td>This will be set to the direction that minimizes the sum squared distances of projections of peaks from integer multiples of the specified plane spacing. </td></tr>
    <tr><td class="paramname">q_vectors</td><td>List of peak positions, specified according to the convention that |q| = 1/d. (i.e. Q/2PI) </td></tr>
    <tr><td class="paramname">direction_list</td><td>List of possible directions for plane normals. Initially, this will be a long list of possible directions from <a class="el" href="../../df/d68/classMantid_1_1Geometry_1_1IndexingUtils.html#a983611c692ef0e464065682b60268efe" title="Make list of direction vectors uniformly distributed over a hemisphere.">MakeHemisphereDirections()</a>. </td></tr>
    <tr><td class="paramname">plane_spacing</td><td>The required spacing between planes in reciprocal space. </td></tr>
    <tr><td class="paramname">required_tolerance</td><td>The maximum deviation of the component of a peak Qxyz in the direction of the best_direction vector for that peak to count as being indexed. NOTE: The tolerance is specified in terms of Miller Index. That is, the distance between adjacent planes is effectively normalized to one for measuring the error in the computed index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of peaks that lie within the specified tolerance of the family of planes with normal direction = best_direction and with spacing given by plane_spacing.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>exception of no Q vectors or directions are specified. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02726">2726</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd8/IndexPeaks_8cpp_source.html#l00133">error</a>, <a class="el" href="../../d4/d3f/Kernel_2src_2V3D_8cpp_source.html#l00130">Mantid::Kernel::V3D::normalize()</a>, and <a class="el" href="../../dd/dcf/V3D_8h_source.html#l00274">Mantid::Kernel::V3D::scalar_prod()</a>.</p>

</div>
</div>
<a id="aed0428b3c05dd21f5a5082d5a29bc57c" name="aed0428b3c05dd21f5a5082d5a29bc57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0428b3c05dd21f5a5082d5a29bc57c">&#9670;&#160;</a></span>ValidIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IndexingUtils::ValidIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d9d/classMantid_1_1Kernel_1_1V3D.html">Kernel::V3D</a> &amp;&#160;</td>
          <td class="paramname"><em>hkl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check is hkl is within tolerance of integer (h,k,l) non-zero values. </p>
<p >Check whether or not the components of the specified vector are within the specified tolerance of integer values, other than (0,0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hkl</td><td>A V3D object containing what may be valid Miller indices for a peak. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum acceptable deviation from integer values for the Miller indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all components of the vector are within the tolerance of integer values (h,k,l) and (h,k,l) is NOT (0,0,0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02053">2053</a> of file <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d66/SetUncertainties_8cpp_source.html#l00054">tolerance</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02031">withinTol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02344">CalculateMillerIndices()</a>, <a class="el" href="../../d3/dac/FindUBUsingIndexedPeaks_8cpp_source.html#l00040">Mantid::Crystal::FindUBUsingIndexedPeaks::exec()</a>, <a class="el" href="../../d9/d85/OptimizeCrystalPlacement_8cpp_source.html#l00139">Mantid::Crystal::OptimizeCrystalPlacement::exec()</a>, <a class="el" href="../../d7/d00/IntegrateEllipsoidsTwoStep_8cpp_source.html#l00110">Mantid::MDAlgorithms::IntegrateEllipsoidsTwoStep::exec()</a>, <a class="el" href="../../d8/d3b/IntegrateEllipsoidsV1_8cpp_source.html#l00306">Mantid::MDAlgorithms::IntegrateEllipsoidsV1::exec()</a>, <a class="el" href="../../dd/d8e/Integrate3DEvents_8cpp_source.html#l00846">Mantid::MDAlgorithms::Integrate3DEvents::getHklMnpKey()</a>, <a class="el" href="../../dd/d8e/Integrate3DEvents_8cpp_source.html#l00739">Mantid::MDAlgorithms::Integrate3DEvents::getHklMnpKey2()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02534">GetIndexedPeaks()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02464">GetIndexedPeaks_3D()</a>, <a class="el" href="../../d3/dac/FindUBUsingIndexedPeaks_8cpp_source.html#l00231">Mantid::Crystal::FindUBUsingIndexedPeaks::isPeakIndexed()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02175">NumberIndexed()</a>, <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02251">NumberIndexed_3D()</a>, and <a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html#l02070">NumberOfValidIndexes()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae602e29db9ec2a53a214fc20045305de" name="ae602e29db9ec2a53a214fc20045305de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae602e29db9ec2a53a214fc20045305de">&#9670;&#160;</a></span>g_Log</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d78/classMantid_1_1Kernel_1_1Logger.html">Mantid::Kernel::Logger</a>&amp; Mantid::Geometry::IndexingUtils::g_Log</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static reference to the logger class. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/de5/IndexingUtils_8h_source.html#l00199">199</a> of file <a class="el" href="../../d8/de5/IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Framework/Geometry/inc/MantidGeometry/Crystal/<a class="el" href="../../d8/de5/IndexingUtils_8h_source.html">IndexingUtils.h</a></li>
<li>Framework/Geometry/src/Crystal/<a class="el" href="../../de/d8c/IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 3 2023 12:00:20 for Mantid by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
